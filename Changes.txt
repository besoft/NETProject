7.10.2013 - Local Database
* Added migrations (Tools/Library Package Manager/Package Manager Console: enable-migrations) + enabled automatic updates
	Advantage:	When the application is run it should update automatically the database to the latest version
				(see http://msdn.microsoft.com/en-us/data/jj591621). Problem is that AutoMigrations seems not
				working correctly in many cases yielding various errors such as "Data loss".

* Specified the Connection string to local database (see App.config)
	Advantage:	we control which database should be used and where it should be located.

* POCO classes updated so that their members are annotated by Data attributes
	
	Advantage:	this allows an easy specification of various constraints (e.g., Personal number may not be null).

* Added custom validation such as "Personal number" must be unique and the number of points cannot exceed the maximum.
				

4.10.2013 - Code-First Simple but Working Entity Framework

* ViewModel modified to a better design: Create and Edit no longer does the changes into the repository but only
  marks the object as Added or Modified and until AcceptChanges or CancelChanges is called changes are purely local.

	Advantage:	this corresponds better to how the user interacts with the application: the user clicks on button
				"Add" and gets some GUI where they fill the appropriate data and after that they click either OK
				to confirm their edits or Cancel to abort the changes.
	Note:		This solves the problem 8.
	Problem:	9) Cancel has no effect for local (in-memory) objects, i.e., it fails to do anything for repositories

* AcceptChanges calls Save to transfer the entity data into the database
	Note:		This is solution (b) to the problem 6
	Problem:	10) For Xml repository, this solution actually means that after a single change, the whole repository
				is serialized into a Xml file, which harms the performance as this is required to be done only once.
				As Xml repository is supposed to be used for "Test" purposes only, this problem is not to be saved!
	
* Lazy loading enabled for Evaluations + StudentViewModel.DisplayList updated to adopt eager loading.
	Note:		This solves the problem 7



4.10.2013 - Code-First Simple Entity Framework

* Added Entity Framework and classes DbRepository, DbStudentEvaluationContext and DbStudentEvaluationUnitOfWork
	
	Note:		Compare DbStudentEvaluationUnitOfWork and LocalStudentEvaluationUnitOfWork
				Compare DbStudentEvaluationContext and LocalStudentEvaluationContext
				Compare DbRepository and LocalRepository

	Problems:	6) Changes are not visible until Save. The reason is that DbRepository.Get retrieves data from
				database but not from memory, so it cannot retrieve unsaved changes. Possible solutions are:
				
				a) Load all data from the database into memory and modify DbRepository.Get to work with .Local
				datasets (contains loaded and newly added objects). 

				Advantage: everything is local, i.e., it would work fine

				Disadvantage: loading everything into memory is both time and memory consuming + changes done
				by other users are not reflected until the application is reloaded. Risk of problems.

				b) ViewModel should call Save after a change is complete

				Advantages: Lower risk of concurrency problems, suitable for MVC where objects are detached
				Disadvantage: Any change is stored immediately - ?can this be altered by using transactions?

				7) When retrieved from database Evaluations in students and categories are empty and similarly
				Student and Category in evaluations are null (unless Students and Categories are loaded first).
				The reason for this behaviour is that currently POCO classes and repositories are configured
				to use Explicit loading model, i.e., you need to call Load to get related objects into the memory.
				To make it work, however, would also need to add Foreign Keys CustomerId and StudentId into Evaluation 
				class. There are two other loading models: 
				a) Eager loading - it is necessary to specify what should be retrieved automatically from DB in
				includeProperties array of method Get. It is not recommended mode if you retrieve lot of stuff but 
				not using it (large and complex single query).
				b) Lazy loading - used by default if "virtual" is added to Evaluations collections definition in
				Student and Category (EF replace List<> by its own implementation). Not recommended, if you need
				really all related data (multiple queries instead only one).

				8) Current View and ViewModel does not contain "ApplyChanges" after "EditDetail" was called,
				so it makes the update operation not working at all.

*  Problems 2 and 5 solved automatically by switching to EF

3.10.2013 - Xml Persistent Data Context

* Added XmlStudentEvaluationContext concrete class of data context that supports serialization of repositories
 to external Xml file (stored on a local disk).

	Note:		This demonstrates how easily you can change something without necessity to modify many classes.
				XmlSerializer and also App.config configurations are also demonstrated.

* Fixed problem with Id not automatically assigned

3.10.2013 - UnitOfWork pattern

* Added generic IRepository and IUnitOfWork with the default in-memory only implementation
			
	Note:		see Repository_pattern_diagram.png; Id has been added into every POCO class
	Advantage:	presentation layer does not access data context directly but through multiple repositories
				of the same interface that are grouped into a unit of work that is responsible for 
				construction of these repositories above the same underlying data context. As a result, 
				switching from a database data context to in-memory only data context requires only
				a change of one line where the object of concrete unit of work is constructed. The rest
				is automatic thanks to interfaces used.

	Problems:	5) Adding Evaluation should automatically add the reference to collections of referenced
				Category and Student. This problem is not simple to solve [lot of code] and as EF data context
				takes automatically care of this, we are not going to solve this problem and leaving it for
				caller to fill POCO classes correctly.

* Problems 1 and 4 from CRUD business logic has been fixed.


2.10.2013 - CRUD business logic

* Added StudentRepository (implements IStudentRepository) with the Create, Read, Update and Delete business logic

	Advantage:	presentation layer does not access data context (StudentEvaluationContext) directly but through 
				IStudentRepository, which enables changing of the data context (e.g., we may have in-memory only
				or persistent data contexts and the latter may be via XML serialization, binary file stream,
				SharePoint, Entity Framework database, ...) without changing the presentation layer.

	Problems:	1) GetStudents method reads all students from the physical data context (e.g., from disk)
				into memory but its caller typically filters this list using LINQ to get only relevant data.
				If data context represents a database context and the database is remote, this actually means
				that lot of data must be transferred via the network just to be then discarded. 
				
				This problem may be solved easily by specifying filters as parameters of the method.
				see http://www.asp.net/mvc/tutorials/getting-started-with-ef-using-mvc/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application

				2) As StudentEvaluationContext and StudentRepository represents in-memory only data,
				it provides the caller with the original objects so that any change in the object is
				immediately seen within the data context and it cannot be undone.

				This problem will be ignored since we are targeting at EF where this is solved automatically.
				Solving this problem with in-memory only data would require cloning objects and tracking changes,
				which is too difficult for the purpose of this tutorial.

* Added View and ViewModel to support MVVM software pattern

	Note:		Three software patterns are currently commonly used in practice, each of them aiming at forming
				various layers in the application with minimal dependency so that the code in any layer can be easily 
				replaced by another code without the necessity to change the code in other layers.
				1) Model View Presenter (MVP) = Presenter represent the main core of the application, it knows the
				model (with its Data Abstract Layer - DAL) and also Views (User UI), formatting the data of the model 
				for Views to visualize them to the user, whilst accepting the calls from Views triggered by the user
				action to get the data from the Views and update the Model according to these changes. MVP is
				suitable form MFC and WinForms applications. For example, each form has public properties to get/set
				and method ShowDialog (all these coming from some interface) and its implementation of ShowDialog
				transfers (e.g., via data binding) its public properties to some properties of controls it displays
				and when the form is closed with OK or Apply, values from controls are transferred to these public
				properties. Presenter has access to the repository so it can take the model object, transfer its
				relevant properties to properties of a form (via the interface) and calling "ShowDialog". If the
				user wants to accept their changes, the model object is modified accordingly and optionally saved
				immediately into the underlying physical repository.
				2) Model View Controller (MVC) = Similar to MVP, designed for web applications, controller gets
				the requests from the user (via web browser) and provides the user with passive views. Actually,
				the only important difference between MVC and MVP is that the method of the controller exits 
				before the user interaction with the view takes its place and another method of the controller is
				called after the user interaction is done. It is IIS (or another web server) that communicates 
				with the controller.
				3) Model View ViewModel (MVVM) = Similar to MVP with one major difference as follows. As View in MVP
				contains some code for transferring the properties to UI controls and back, there is a potential
				risks of bugs requiring some testing (e.g., when nothing is selected in the list, is the button
				"Delete" really disabled?). However, these tests cannot be automated. MVVM comes with a special remedy
				to this problem: MVVM Views are striped of this logic and this is transferred to Presenter that is
				renamed to ViewModel to reflect new added functionality. This means that ViewModel has to provide
				means to select the items (that will be in the list) and property to count the number of selected
				items, which is in MVP pattern handled by controls of View. These properties are mapped to View 
				controls via binding (provided by Microsoft). As it is, only proper binding must be checked for Views, 
				and ViewModels may by automatically tested from code. MVVM is designed for WPF.

	Advantage:	StudentView that currently shows the information about students onto the console can be replaced
				by more sophisticated GUI without any change of business logic, e.g., finding the item to delete,
				confirmation of the deletion by the user, and the deletion itself is unchanged.

	Problems:	3) Currently the pattern resembles MVP instead of MVVM despite the names. This is only a formalism,
				however. True MVVM will be there once Console application is replaced by WPF desktop application.

* Category and Evaluation is ignored for now, construction of CRUD objects would be similar.
	Problems:	4) While Student have unique key (PersonalNumber), and for Category we may consider this to be its Name,
				for Evaluation nothing like this exists (one may use Student.PersonalNumber + Category.Name but it
				is a bit awkward). Solution would be to introduce some internal identifier, e.g., int Id and for 
				consistency the same could be done for Student and Category (working with strings is slower than
				working with integers).

1.10.2013 - POCO (Plain Old CLR Object) classes for Student, Category and Evaluation
30.7.2013 - Blank solution